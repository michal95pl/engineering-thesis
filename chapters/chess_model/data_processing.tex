\setcounter{chapter}{0}

\chapter[Zbiór danych gier szachowych {[\textit{Michał Lichtarski}]}]{Zbiór danych gier szachowych}

Przygotowanie zbioru danych jest kluczowym etapem w uczeniu maszynowym. Od jakości oraz formatu danych zależy końcowa skuteczność modelu. Do trenowania modelu wykorzystano zbiór \textit{Lichess Elite Database} \footnote{Dane zostały pobrane ze strony \textit{database.nikonoel.fr}} zawierający rozgrywki graczy na poziomie większym niż 2300 ELO, co odpowiada poziomowi mistrzowskiemu. Co ważne, zbiór ten nie zawiera powtórzeń, a także rozgrywek typu bullet, dzięki czemu model nie uczy się złych, nietypowych strategii tworzonych pod presją czasu. Pobrany zbiór danych składa się z kilku plików o rozszerzeniu \textit{.pgn}.

\section{Format danych PGN}
Format PGN jest powszechnie stosowanym standardem przechowywania partii szachowych. W pojedynczym pliku może znajdować się dowolna ilość gier. Każda z nich zawiera między innymi informacje o nazwach graczy, wyniku oraz stosie ruchów. Taki sposób zapisu jest bardzo efektywny pamięciowo, gdyż nie zapisuje pełnego stanu planszy w każdej turze, a jedynie wykonywane ruchy. Dodatkowym atutem jest gotowa biblioteka \textit{python-chess} służąca do dekodowania pliku oraz znajdujących się w nich rozgrywek.

\vspace{0.5cm}

\begin{lstlisting}[
    language=Python, 
    caption=przykład pliku PGN,
    inputencoding=utf8,
    basicstyle=\ttfamily\footnotesize,
    xleftmargin=0.1cm,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    keepspaces=true
]
[Event "F/S Return Match"] 
[Site "Belgrade, Serbia JUG"] 
[Date "1992.11.04"] 
[Round "29"] 
[White "Fischer, Robert J."]
[Black "Spassky, Boris V."] 
[Result "1/2-1/2"] 

1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 ...
\end{lstlisting}

\hspace{1cm}

\section{Notacja FEN}
Notacja FEN jest standardową formą zapisu stanu planszy szachowej. Jest ona reprezentowana w postaci ośmiu linii oddzielonych znakiem "/". Każda z nich zawiera pierwsze litery angielskich nazw figur np: p od pawn, b od bishop itp. Dodatkowo w przypadku białych figur, jest to wielka litera, a w przypadku czarnych mała. Cyfry oznaczają ilość pustych pól. Na przykład: PPPP1PP oznacza cztery białe pionki, jedno puste pole oraz dwa białe pionki. Po zakodowanych polach planszy występują dodatkowe informacje: kolor gracza wykonującego ruch, prawa do roszady, pola na których możliwe jest bicie w przelocie, licznik półruchów oraz numer rundy. 
Taki format daje możliwość bardzo łatwego przesyłania oraz zapisywania obiektu klasy \textit{Board} bez wykonywania serializacji, co w dalszej części pracy zostanie wykorzystane.

\begin{lstlisting}[
    language=Python,
    caption=Przykład notacji FEN,
    inputencoding=utf8,
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{gray!10},
    frame=single,
    showspaces=false,
    showstringspaces=false,
    numbers=none
]
>>> board = chess.Board("r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8
/PPPP1PPP/RNB1K1NR b KQkq - 0 4")
>>> print(board)
r . b q k b . r
p p p p . Q p p
. . n . . n . .
. . . . p . . .
. . B . P . . .
. . . . . . . .
P P P P . P P P
R N B . K . N R
\end{lstlisting}

\section{Klasa PGNDataset}
W celu przetworzenia danych została stworzona klasa \textit{PGNDataset}. Jej zadaniem jest generowanie plików o rozszerzeniu \textit{.rdg} zawierających zserializowany obiekt krotki składający się z trzech tablic. Pierwsza z nich przechowuje zakodowane ruchy, druga plansze, a trzecia wyniki partii. Ze względów na dużą ilość danych, klasa ta działa równolegle wykorzystując wieloprocesowość, gdzie każdy z procesów przetwarza osobny plik \textit{.pgn}. Dzięki takiemu podejściu, czas potrzebny na przetworzenie całego zbioru danych jest znacznie krótszy przy wykorzystaniu wielordzeniowego procesora. Ilość używanych procesów można ustawić w pliku \textit{config.json} pod kluczem \textit{number\_of\_converting\_processes}.

Każdy plik \textit{.rdg} zawiera trójczłonową nazwę. Pierwszy człon to id procesu, który go stworzył, drugi to numer porządkowy pliku, a trzeci oznacza ilość zakodowanych ruchów. Pierwsze dwa człony pełnią role identyfikatora, natomiast trzeci umożliwia wizualizację postępu podczas używania różnych narzędzi.

Ilość zapisanych gier w jednym pliku jest konfigurowalna i można ją ustawić w pliku konfiguracyjnym pod kluczem \textit{max\_games\_per\_train\_file}. Dobranie odpowiedniej wartość zależy przede wszystkim od ilości pamięci RAM. Dobrana wartość również może wpłynąć na jakość modelu, gdyż zbyt duża ilość gier może nie umożliwić odpowiedniego przemieszania dużej ilości danych z różnych plików podczas trenowania.


Dodatkowo klasa ta umożliwia wyodrębnienie zbioru testowego poprzez losową selekcję gier do osobnego folderu. Wydzielenie osobnych całych gier a nie samych ruchów jest bardzo istotne, gdyż ruchy w jednej grze mogą być ze sobą powiązane. Prowadziło by to do wycieku danych między zbiorem treningowym, a testowym. Proporcje podziału można również ustawić w pliku konfiguracyjnym pod kluczem \textit{test\_split\_ratio}. W jednym pliku jest zapisywana $test\_split\_ratio * max\_games\_per\_train\_file$ ilość gier. Przed zapisem do pliku ruchy są mieszane w losowej kolejności w celu poprawienia jakości trenowania modelu.

\section{Kodowanie gier}
Działanie klasy \textit{PGNDataset} rozpoczyna się od metody \textit{encode directory}, która przyjmuje ścieżke do katalogu z plikami \textit{.pgn}. Następnie iteruje po wszystkich plikach, gdzie dla każdej gry wywołuje metodę \textit{encode game}. Jej zadaniem jest enkodowanie wszystkich stanów z gry do trzech list zawierające: ruchy, stany plansz oraz wyniki. Co ważne, dla każdego stanu są zapisywane dodatkowo dwa poprzednie stany plansz. Pozwala to na zachowanie kontekstu rozgrywki podczas trenowania, a dodatkowo zwiększa różnorodność danych. Ze względu na to, że model uczy się jedynie ruchów dla białych figur, podczas ruchu czarnych plansza jest odbijana względem osi X wraz ze zmianą perspektywy ruchu oraz wyniku partii. Może wydawać się to nieintuicyjne, gdyż nie odzwierciedla to rzeczywistego obrotu planszy, aczkolwiek pozwala to na zachowanie spójności gry niezależnie od koloru gracza. Należy zauważyć, że szachy nie są grą symetryczną, gdyż z punktu widzenia jednego z graczy król znajduje się po jego prawej stronie, a dla drugiego po lewej. Z tego powodu odbicie planszy również po osi Y mogłoby wprowadzić błędy w trenowaniu modelu.

\section{Enkodowanie planszy}
Enkodowanie planszy polega na stworzeniu macierzy o wymiarach 8x8 przechowującej informacje o figurach. Są one kodowane jako liczby od 0 do 12. Wartości od 0 do 5 oznaczają białe, a od 6 do 11 czarne figury, natomiast 12 reprezentuje puste pole.

\section{Dekodowanie i enkodowanie ruchów}
Dekodowanie i enkodowanie ruchów jest bardzo podobne jak ma to miejsce w Alphazero. Ruchy są indeksowane od 0 do 77.

Wyróżniamy 2 grupy ruchów: ruchy prostoliniowe oraz nietypowe. Do pierwszej grupy zaliczamy ruchy wszystkich figur oprócz skoczka. Druga grupa to ruchy skoczka oraz specjalne, czyli roszada i promocje.

Ruchy prostolinijne są indeksowane na podstawie kierunku oraz odległości. Rozróżniamy 8 kierunków: 2 pionowe i poziome oraz 2 diagonalne. Każdy z tych kierunków posiada 7 możliwych odległości, gdyż maksymalnie figura może poruszyć się o 7 pól. W ten sposób uzyskujemy 56 indeksów \cite{AlphaZero}.

\hspace{0.5cm}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{images/normal moves.png}
\caption{Indeksowanie ruchów prostoliniowych}
\end{figure}

Indeksowanie ruchów gońca oraz specjalnych jest z góry ustalone. Skoczek posiada 8 możliwych ruchów. Natomiast promocje pionka są dzielone na 12 ruchów zależnie od tego, w jaki sposób pionek dostanie się na ostatni rząd. Może to być ruch prawo lub w lewo poprzez zbicie figury, albo naturalnie prosto do przodu. Dodatkowo każda z tych opcji posiada 4 możliwości promocji: hetman, wieża, goniec oraz skoczek. 
Ostatnim specjalnym ruchem jest roszada, która posiada 2 indeksy: krótka (królewska) oraz długa (hetmańska).

Istnieje bardziej skompresowany sposób kodowania ruchów. Polega on na kodowaniu z punktu widzenia położenia figury na planszy. Sposób ten działa analogicznie do windy, gdzie wybieramy na jakie piętro (pole) chcemy wjechać. Dla przykładu, jeśli chcemy z pola E4 wykonać ruch gońcem na pole c6, to jest to ruch w lewo na 6 rząd, co jest równe indeksowi 25. W porównaniu do poprzedniego sposobu jest znacznie mniej stanów (32 zamiast 56), aczkolwiek zawiera ona jedną, bardzo dużą wadę. Takie rozwiązanie jest sprzeczne z ideą wykorzystywanych warstw konwolucyjnych, które charakteryzują się niezmienniczością przestrzenną. Temat ten zostanie rozwinięty w dalszej części pracy.
\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{images/lift method.png}
\caption{Przykład indeksowania ruchów drugim sposobem}
\end{figure}
\newpage

