\setcounter{chapter}{6}
\chapter[Identyfikacja i lokalizacja figur szachowych {[\textit{Marcin Ziółkowski}]}]{Identyfikacja i lokalizacja figur szachowych}

Po dokonaniu transformacji perspektywicznej szachownicy, system przystępuje do kluczowej fazy określenia stanu gry. Proces ten łączy techniki klasycznego przetwarzania obrazu z głębokim uczeniem maszynowym i składa się z trzech głównych filarów: precyzyjnej lokalizacji obiektów, identyfikacji ich typu oraz koloru, a także finalnej konwersji danych do formatu FEN za pomocą modułu walidacyjnego.

\section{Metodyka lokalizacji figur szachowych}
Lokalizacja figur szachowych w systemie realizowana jest dwuetapowo, co zapewnia wysoką odporność na niedokładności mechaniczne oraz błędy w orientacji tokenów.

\subsection{Lokalizacja siatkowa (Grid-based Localization)}
Pierwszym stopniem lokalizacji jest podział obrazu szachownicy na regularną siatkę $8 \times 8$. Dzięki wcześniejszej transformacji perspektywicznej, każde z 64 pól posiada stałe współrzędne relatywne. Następnie system iteracyjnie wycina fragmenty obrazu odpowiadające poszczególnym polom, tworząc zestaw obrazów wejściowych dla dalszej analizy.

\subsection{Lokalizacja wewnątrz pola i detekcja obecności}
Wewnątrz każdego wyciętego pola klasa \texttt{EllipseCrop} przeprowadza precyzyjną lokalizację obiektu. Wykorzystanie funkcji \texttt{cv2.fitEllipse} pozwala na wyznaczenie środka ciężkości figury szachowej. Jeśli algorytm nie odnajdzie konturów spełniających kryteria rozmiarowe (funkcja \texttt{find}), pole klasyfikowane jest jako puste. Zapobiega to błędnym predykcjom sieci CNN dla szumu tła lub cieni.

\section{Lokalne progowanie adaptacyjne}
Ze względu na zmienne warunki oświetleniowe oraz cienie rzucane przez figury, zastosowanie globalnego progu binaryzacji okazało się niewystarczające. Algorytm wyznacza progi na podstawie analizy bimodalnej histogramu intensywności pikseli dla każdego pola z osobna.

\begin{equation}
    T = \frac{mode_{dark} + mode_{bright}}{2}
\end{equation}

\newpage

Poniżej przedstawiono implementację funkcji wyznaczającej próg na podstawie histogramu:

\begin{lstlisting}[style=codeListingStyle, caption={Analiza bimodalna histogramu do wyznaczenia progu}]
def hist_modification(hist):
    dark_mode = np.argmax(hist[1:128])
    bright_mode = np.argmax(hist[128:]) + 128
    thr = (dark_mode + bright_mode) / 2
    return thr, bright_mode, dark_mode
\end{lstlisting}

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{chapters/chess_identification/images/Binary_treshold.png}
\caption[lokalne progowanie adaptacyjne dla pola szachownicy]{Wykres ilustrujący lokalne progowanie adaptacyjne dla pola szachownicy}
\end{figure}

\section{Ekstrakcja obiektu i Ellipse Crop}
Klasa \texttt{EllipseCrop} realizuje autorską metodę kadrowania opartego na detekcji elipsy podstawy figury. Proces ten ma na celu ujednolicenie danych wejściowych dla sieci neuronowej poprzez usunięcie tła pola szachownicy. Poniżej przedstawiono siedem kluczowych etapów przetwarzania obrazu w tej fazie:

\begin{enumerate}
    \item \textbf{Obraz wejściowy i binaryzacja (Gray):} Obraz pola zostaje skonwertowany do odcieni szarości i poddany progowaniu przy użyciu lokalnego progu $T$.
    \item \textbf{Detekcja krawędzi (Edges):} Wykorzystanie operatora Canny'ego z progami adaptacyjnymi.
    \item \textbf{Dylatacja (Dilated):} Domykanie konturów za pomocą operacji morfologicznej.
    \item \textbf{Wizualizacja detekcji (Ellipse):} Dopasowanie elipsy do największego konturu (\texttt{cv2.fitEllipse}).
    \item \textbf{Maska binarna (Mask):} Wygenerowanie maski wypełniającej wnętrze elipsy.
    \item \textbf{Segmentacja (Masked):} Wycięcie obiektu z tła (\texttt{bitwise\_and}).
    \item \textbf{Normalizacja rozmiaru (Cropped):} Przeskalowanie obiektu.
\end{enumerate}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{chapters/chess_identification/images/steps/identification_Gray1.png}
        \caption{Etap 1: Binaryzacja}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{chapters/chess_identification/images/steps/identification_Edges2.png}
        \caption{Etap 2: Krawędzie Canny}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{chapters/chess_identification/images/steps/identification_Dilated3.png}
        \caption{Etap 3: Dylatacja}
    \end{minipage}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.24\textwidth}
        \centering
        \includegraphics[width=\textwidth]{chapters/chess_identification/images/steps/identification_Ellipse4.png}
        \caption{Etap 4: Detekcja}
    \end{minipage}
    \hfill
    \begin{minipage}{0.24\textwidth}
        \centering
        \includegraphics[width=\textwidth]{chapters/chess_identification/images/steps/identification_Mask5.png}
        \caption{Etap 5: Maska}
    \end{minipage}
    \hfill
    \begin{minipage}{0.24\textwidth}
        \centering
        \includegraphics[width=\textwidth]{chapters/chess_identification/images/steps/identification_Masked6.png}
        \caption{Etap 6: Wycięcie}
    \end{minipage}
    \hfill
    \begin{minipage}{0.24\textwidth}
        \centering
        \includegraphics[width=\textwidth]{chapters/chess_identification/images/steps/identification_Cropped7.png}
        \caption{Etap 7: Skalowanie}
    \end{minipage}
\end{figure}

\vspace{1cm}
Poniższy fragment kodu prezentuje główną logikę składania tych etapów:

\begin{lstlisting}[style=codeListingStyle, caption={Zarządzanie potokiem przetwarzania Ellipse Crop}]
def apply(self, img, thr, bright_node, dark_node, step_visualize=False):
    H, W = img.shape[:2]
    vis = img.copy()

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    _, img = cv2.threshold(gray, thr, 255, cv2.THRESH_BINARY)
    best_ellipse = self.detect_ellipse(vis, thr, bright_node, dark_node, step_visualize=step_visualize)

    if best_ellipse is None:
        cx, cy = W // 2, H // 2
        r = min(W, H) // 2
        best_ellipse = ((cx, cy), (2*r, 2*r), 0)

    (cx, cy), (w, h), angle = best_ellipse
    w_scaled = w * self.scale
    h_scaled = h * self.scale
    best_ellipse_scaled = ((cx, cy), (w_scaled, h_scaled), angle)
    mask = np.zeros((H, W), dtype=np.uint8)

    if w > 0 and h > 0:
        cv2.ellipse(mask, best_ellipse_scaled, 255, -1)
    else:
        r = min(W, H) // 2
        cv2.circle(mask, (W // 2, H // 2), r, 255, -1)

    self._show("Mask5", mask)
    masked = cv2.bitwise_and(img, img, mask=mask)
    self._show("Masked6", masked)

    w2, h2 = int(w_scaled/2), int(h_scaled/2)
    x1 = max(0, int(cx - w2))
    y1 = max(0, int(cy - h2))
    x2 = min(W, int(cx + w2))
    y2 = min(H, int(cy + h2))

    cropped = masked[y1:y2, x1:x2]
    self._show("Cropped7", cropped)

    if self.step_visualize:
        cv2.destroyAllWindows()

    return cropped
\end{lstlisting}

\newpage

\section{Identyfikacja figur szachowych i przygotowanie danych}
Rozpoznanie typu i koloru figury szachowej odbywa się poprzez fuzję wyników prostej detekcji koloru oraz predykcji sieci splotowej.

\subsection{Detekcja koloru i klasyfikacja CNN}
Kolor figury szachowej ('W' lub 'B') określany jest na podstawie średniej intensywności jasności segmentu w odniesieniu do progu $T$. Typ figury szachowej (np. Pawn, King) wybierany jest na podstawie najwyższego logitu zwróconego przez model \texttt{ChessCNN}.

\subsection{Kodowanie tablicy szachowej}
Po zakończeniu iteracji przez wszystkie pola, klasa \texttt{BoardIdentification} wykonuje kluczowy krok mapowania wyników na notację algebraiczną za pomocą metody \texttt{encode\_board}. Metoda ta transformuje pary (kolor, typ) na standardowe, jednoznakowe symbole (np. biały goniec $\rightarrow$ 'B', czarny skoczek $\rightarrow$ 'n'). Tak przygotowana tablica $8 \times 8$ stanowi ustandaryzowane wejście dla modułów logiki szachowej.

\begin{lstlisting}[style=codeListingStyle, caption={Proces identyfikacji i kodowania pola}]
# Fragment BoardIdentification.identify
color = self.detect_color(sq, thr)
img = self.preprocess(sq)
pp = self.model(img)
pi = pp.argmax(1).item() # Najwyzszy logit
row.append(f"{color}_{self.pieces[pi]}")

# Fragment BoardIdentification.encode_board
mapping = {"W_King": "K", "B_King": "k", ...}
encoded_row.append(mapping.get(cell, " "))
\end{lstlisting}

\section{Integracja i walidacja stanu (JsonUpdater)}
Ostatnim etapem jest przekazanie zakodowanej tablicy do klasy \texttt{JsonUpdater}. Moduł ten pełni rolę pomostu pomiędzy warstwą wizyjną a silnikiem szachowym.

\subsection{Konwersja na obiekty szachowe}
Metoda \texttt{convert\_chessBoard} w klasie \texttt{JsonUpdater} przyjmuje tablicę z jednoznakowymi identyfikatorami. Dzięki temu proces tworzenia obiektu \texttt{chess.Piece} jest uproszczony do bezpośredniego odczytu z mapy symboli.

\newpage

\begin{lstlisting}[style=codeListingStyle, caption={Konwersja identyfikatorow na obiekty biblioteki python-chess}]
def convert_chessBoard(self, newlist):
    board = chess.Board(None)
    piece_map = {
        'P': chess.Piece(chess.PAWN, chess.WHITE),
        'R': chess.Piece(chess.ROOK, chess.WHITE),
        'N': chess.Piece(chess.KNIGHT, chess.WHITE),
        'B': chess.Piece(chess.BISHOP, chess.WHITE),
        'Q': chess.Piece(chess.QUEEN, chess.WHITE),
        'K': chess.Piece(chess.KING, chess.WHITE),

        'p': chess.Piece(chess.PAWN, chess.BLACK),
        'r': chess.Piece(chess.ROOK, chess.BLACK),
        'n': chess.Piece(chess.KNIGHT, chess.BLACK),
        'b': chess.Piece(chess.BISHOP, chess.BLACK),
        'q': chess.Piece(chess.QUEEN, chess.BLACK),
        'k': chess.Piece(chess.KING, chess.BLACK),
    }
    for row in range(8):
        for col in range(8):
            cell = newlist[row][col]
            if cell != ' ':
                square = chess.square(col, 7 - row)
                board.set_piece_at(square, piece_map[cell])
    return board
\end{lstlisting}

\subsection{Walidacja i zapis FEN}
Przed zapisaniem stanu do pliku \texttt{data.json}, \texttt{JsonUpdater} weryfikuje poprawność przejścia (funkcja \texttt{is\_transition\_possible}). Sprawdzane jest, czy wykryty stan wynika z dozwolonego ruchu, co pozwala wyeliminować błędy spowodowane chwilowym przesłonięciem szachownicy przez rękę gracza. Finalny stan gry zapisywany jest w formacie FEN.