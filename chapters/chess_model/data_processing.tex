\setcounter{chapter}{0}

\chapter{Zbiór danych}
Tworzenie zbioru danych jest bardzo istotnym etapem w uczeniu maszynowym. Od ich jakości oraz formatu zależy skuteczność modelu. Dane użyte do trenowania zostały pobrane ze strony \textit{lichess.org}. Został wykorzystany zbiór \textit{Lichess Elite Database} zawierający rozgrywki graczy na poziomie większym niż 2300, co jest bardzo wysokim wynikiem. Co ważne, zbiór ten nie zawiera powtórzeń, a także rozgrywek czasowych dzięki temu model nie uczy się złych, nietypowych strategii tworzonych pod presją czasu. Pobrany zbiór danych składa się z kilku plików o rozszerzeniu \textit{.pgn}.

\section{Format danych PGN}
Format PGN jest powszechnie stosowanym formatem do przechowywania partii szachowych. W danym pliku może znajdować się dowolna ilość gier. Każda z nich ma między innymi nazwy graczy, wynik oraz stos ruchów. Taki sposób zapisu jest bardzo efektywny pamięciowo, gdyż nie zapisuje pozycji na planszy w każdej turze, a jedynie wykonywane ruchy. Dodatkowym atutem jest gotowa biblioteka python-chess służąca do dekodowania pliku oraz rozgrywania partii.

\vspace{0.5cm}

\begin{lstlisting}[
    language=Python, 
    caption=przykład pliku PGN,
    inputencoding=utf8,
    basicstyle=\ttfamily\footnotesize,
    xleftmargin=0.1cm,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    keepspaces=true
]
[Event "F/S Return Match"] 
[Site "Belgrade, Serbia JUG"] 
[Date "1992.11.04"] 
[Round "29"] 
[White "Fischer, Robert J."]
[Black "Spassky, Boris V."] 
[Result "1/2-1/2"] 

1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 ...
\end{lstlisting}

\section{Notacja FEN}
Notacja FEN jest standardową formą zapisu stanu planszy szachowej. Jest ona reprezentowana w postaci 8 linii oddzielonych znakiem "/". Każda z nich zawiera pierwsze litery angielskich nazw figur np: p od pawn, b od bishop itp. Dodatkowo w przypadku białych figur, jest to wielka litera, a w przypadku czarnych mała. Cyfry oznaczają ilość pustych pól. Na przykład: PPPP1PP oznacza cztery białe pionki, jedno puste pole oraz dwa białe pionki. Po zakodowanych polach planszy, występują dodatkowe informacje oddzielone spacją: kolor gracza który wykonuje ruch, prawa do roszady, pola na których można wykonać bicie w przelocie, licznik półruchów oraz numer rundy. 
Taki format daje możliwość bardzo łatwego przesyłania oraz zapisywania obiektu board, bez wykonywania serializacji, co w dalszej części pracy zostanie wykorzystane.

\newpage

\begin{lstlisting}[
    language=Python,
    caption=Przykład notacji FEN,
    inputencoding=utf8,
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{gray!10},
    frame=single,
    showspaces=false,
    showstringspaces=false,
    numbers=none
]
>>> board = chess.Board("r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8
/PPPP1PPP/RNB1K1NR b KQkq - 0 4")
>>> print(board)
r . b q k b . r
p p p p . Q p p
. . n . . n . .
. . . . p . . .
. . B . P . . .
. . . . . . . .
P P P P . P P P
R N B . K . N R
\end{lstlisting}

\section{Klasa PGNDataset}
W celu przetworzenia danych została stworzona klasa PGNDataset. Jej zadaniem jest utworzenie plików o rozszerzeniu .rdg, które zawierają zserializowany obiekt krotki zawierający trzy tablice. Pierwsza z nich przechowuje zakodowane ruchy, druga plansze, a trzecia wyniki partii. Ze względów na dużą ilość danych do przetworzenia, klasa ta działa równolegle wykorzystując procesy. Każdy z nich przetwarza osobny plik \textit{.pgn}, a następnie zapisuje zakodowane dane do osobnego pliku \textit{.rdg}. Dzięki temu czas potrzebny na przetworzenie całego zbioru danych jest znacznie krótszy w przypadku wielordzeniowych procesorów. Ilość używanych procesów można ustawić w pliku \textit{config.json} pod kluczem \textit{number\_of\_converting\_processes}.

Każdy plik \textit{.rdg} zawiera trój członową nazwę. Pierwszy człon to id procesu, który go stworzył, drugi to numer porządkowy pliku, a trzeci to ilość zakodowanych ruchów. Pierwsze człony pełnią role identyfikatora, a trzeci pozwala na stworzenie pasku postępu podczas używania różnych narzędzi.

Ilość zapisanych gier w jednym pliku jest konfigurowalna i można ją ustawić w \textit{config.json} pod kluczem \textit{max\_games\_per\_train\_file}. Dobranie odpowiedniej wartość zależy przedewszystkim od ilości pamięci RAM. Dobrana wartość również może wpłynąć na jakość modelu, gdyż zbyt duża ilość gier może nie umożliwić odpowiedniego wymieszania dużej ilości danych z różnych plików podczas trenowania. 

Dodatkowo klasa ta umożliwia twórzenie zbioru testowego poprzez zapisanie losowych gier do osobnego folderu. Wydzielenie osobnych całych gier, a nie ruchów jest bardzo istotne, gdyż ruchy w jednej grze mogą być ze sobą powiązane, co by prowadziło do wycieku danych między zbiorem treningowym, a testowym. Proporcje tego zbioru można również ustawić w pliku konfiguracyjnym pod kluczem \textit{test\_split\_ratio}. W jednym pliku jest zapisywana $test\_split\_ratio * max\_games\_per\_train\_file$ ilość gier. Przed zapisem do pliku, ruchy są mieszane w losowej kolejności, aby poprawić jakość trenowania modelu.

\section{Kodowanie gier}
Działanie klasy rozpoczyna się od metody \textit{encode directory}, która przyjmuje ścieżke do katalogu z plikami \textit{.pgn}. Następnie iteruje po wszystkich plikach, gdzie dla każdej gry wywołuje metodę \textit{encode game}. Jej zadanie jest enkodowanie wszystkich ruchów do trzech list: ruchów, plansz oraz wyników. Co ważne, dla każdego ruchu są zapisywane dodatkowo dwa poprzednie stany plansz. Pozwala to zachować kontekst rozgrywki podczas trenowania, a dodatkowo zwiększa różnorodność danych. Ze względu na to, że model uczy się jedynie ruchów dla białych figur, podczas ruchu czarnych plansza jest odbijana względem osi X wraz ze zmianą perspektywy ruchu oraz wyniku partii. Może wydawać się to nieintuicyjne, gdyż nie odzwierciedla to rzeczywistego obrotu planszy, aczkolwiek pozwala to na zachowanie spójności gry niezależnie od koloru gracza. Należy zauważyć, że szachy nie są grą symetryczną, gdyż z punktu widzenia jednego z graczy, król znajduje się po jego prawej stronie, a dla drugiego po lewej. Dlatego odbicie planszy również po osi Y mogłoby wprowadzić błędy w nauce modelu.

\section{Enkodowanie planszy}
Enkodowanie planszy polega na stworzeniu macierzy o wymiarach $8x8$ przechowującej informacje o figurach. Są one kodowane jako liczby od 0 do 12. Wartości od 1 do 6 oznaczają białe, a od 7 do 12 czarne figury.

\section{Dekodowanie i enkodowanie ruchów}
Dekodowanie i enkodowanie ruchów jest bardzo podobne jak ma to miejsce w Alphazero. Ruchy są indeksowane od 0 do 77.

Wyróżniamy 2 grupy ruchów: ruchy prostoliniowe oraz nietypowe. Do pierwszej grupy zaliczamy ruchy wszystkich figur oprócz skoczka. Druga grupa to ruchy skoczka oraz specjalne, czyli roszada i promocje.

Ruchy prostolinijne są indeksowane na podstawie kierunku oraz odległości. Rozróżniamy 8 kierunków: 2 pionowe i poziome oraz 2 diagonalne. Każdy z tych kierunków posiada 7 możliwych odległości, gdyż maksymalnie figura może poruszyć się o 7 pól. W ten sposób uzyskujemy 56 indeksów \cite{AlphaZero}.

\hspace{0.5cm}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{images/normal moves.png}
\caption{Indeksowanie ruchów prostoliniowych}
\end{figure}

Indeksowanie ruchów gońca oraz specjalnych jest z góry ustalone. Skoczek posiada 8 możliwych ruchów. Natomiast promocje pionka są dzielone na 12 ruchów, zależnie od tego w jaki sposób pionek dostanie się na ostatni rząd. Może to być ruch prawo, lub w lewo poprzez zbicie figury, lub naturalnie prosto do przodu. Dodatkowo każda z tych opcji posiada 4 możliwości promocji: hetman, wieża, goniec oraz skoczek. 
Ostatnim specjalnym ruchem jest roszada, która posiada 2 indeksy: za króla oraz królewska.

Istnieje bardziej skompresowany sposób kodowania ruchów. Polega on na kodowaniu z punktu widzenia położenia figury na planszy. Sposób ten działa niczym winda, gdzie wybieramy na jakie piętro (pole) chcemy pojechać. Dla przykładu jeśli chcemy z pola E4 wykonać ruch gońcem na pole c6, to jest to ruch w lewo na 6 rząd, co jest indeksem 25. W porównaniu do poprzedniego sposobu, jest znacznie mniej stanów, bo 32 zamiast 56, aczkolwiek zawiera on jedną, bardzo dużą wadę. Takie rozwiązanie jest sprzeczne z ideą wykorzystywanych warstw konwolucyjnych, które charakteryzują się niezmienniczością przestrzenną. Temat ten zostanie rozwinięty w dalszej części pracy.
\begin{figure}[!h]
\centering
\includegraphics[width=0.5\textwidth]{images/lift method.png}
\caption{Przykład indeksowania ruchów drugim sposobem}
\end{figure}
\newpage

